from openai import OpenAI
import openai
import fitz  # PyMuPDF
import PyPDF2
from gensim.summarization import summarize

def get_response(messages):
    """
    Sends messages to the OpenAI chat completion API and returns the response.

    This function sends a list of message dictionaries to OpenAI's chat completion API
    and retrieves a generated response. Each message dictionary must have a 'role'
    (either 'user' or 'system') and 'content' fields.

    Parameters:
    - messages (list of dict): A list of messages where each message is a dictionary
      with 'role' and 'content' keys.

    Returns:
    - str: The content of the response message generated by the API.
    """

    response = openai.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=messages,
        max_tokens=500  # Adjusted max_tokens to allow for longer responses
    )
    content = response.choices[0].message.content
    return content

def summarize_text(text, word_count=400):
    """
    Summarizes the provided text to a specified word count using gensim.

    Attempts to summarize the given text to the desired word count. If the text is
    too short to be summarized to the specified length, it returns the original text.

    Parameters:
    - text (str): The text to be summarized.
    - word_count (int): The desired word count for the summary.

    Returns:
    - str: The summarized text or the original text if it's too short to summarize.
    """

    try:
        # Summarize the text to the desired word count
        summary = summarize(text, word_count=word_count)
        return summary
    except ValueError as e:
        # If the text is too short to summarize, just return the original text
        return text


def extract_text_from_pdf(pdf_path):
    """
    Extracts text from a PDF file using PyMuPDF (fitz) with a fallback to PyPDF2.

    Attempts to extract text from a PDF file, primarily using PyMuPDF (fitz). If it
    fails or extracts no meaningful content, it falls back to using PyPDF2. If both
    methods fail, it returns an empty string.

    Parameters:
    - pdf_path (str): The file path of the PDF from which to extract text.

    Returns:
    - str: The extracted text from the PDF or an empty string if extraction fails.
    """

    # Try extracting text using PyMuPDF (fitz) first
    try:
        doc = fitz.open(pdf_path)
        text = ""
        for page in doc:
            text += page.get_text()
        if text.strip():  # Check if any non-whitespace text was extracted
            return text
    except Exception as e:
        print(f"Error with PyMuPDF (fitz) extraction: {e}")

    # Fallback to PyPDF2 if PyMuPDF fails or extracts no meaningful content
    try:
        with open(pdf_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            text = ''
            for page in reader.pages:
                page_text = page.extract_text() if page.extract_text() else ''
                text += page_text + ' '  # Adding a space after each page's text
        return text
    except Exception as e:
        print(f"Error with PyPDF2 extraction: {e}")

    return ""  # Return empty string if both methods fail


def add_message(messages, content, role):
    """
    Adds a message to the list of messages with the specified role and content.

    Parameters:
    - messages (list of dict): The current list of messages.
    - content (str): The content of the message to add.
    - role (str): The role of the message ('user' or 'system').

    Returns:
    - list of dict: The updated list of messages including the newly added message.
    """
    message = {"role": role, "content": content}
    messages.append(message)
    return messages

def chat():
    """
    Initiates an interactive chat session where users can enter PDF paths to process.

    This function allows users to input a path to a PDF file, then extracts and
    summarizes the text from the PDF, generates a catchy title using the OpenAI API,
    and enters into a chat session to discuss the PDF's content. Users can exit the
    chat or switch to a new PDF by typing 'exit'.

    No parameters or returns as this function is designed to run interactively.
    """

    messages = []
    # Set some limits to prevent infinite loops
    max_pdfs = 1000
    max_messages = 10000

    prompt = input("Enter a PDF path to interact with or type 'exit' to quit:")
    for _ in range(max_pdfs): # Loop over PDFs
        if prompt == "exit":
            print("Exiting chat")
            break
        else:
            pdf_path = prompt.strip()
            if pdf_path.endswith(".pdf") or pdf_path.startswith(".PDF"):
                try:
                    raw_text = extract_text_from_pdf(pdf_path)
                    pdf_text = summarize_text(raw_text, word_count=1000)  # Adjust word_count as needed

                    # pdf_text = extract_text_from_pdf(pdf_path)
                    pdf_text+= "Users can exit the chat by typing 'exit' at any time."
                    # ========== Get that catchy title ==========
                    messages = add_message(messages, pdf_text, "system")  # Adding PDF text as a message from the system
                    messages = add_message(messages, "What is a short catchy title for this pdf?", "user")
                    title = get_response(messages)
                    messages = add_message(messages, title, "assistant")

                    print("="*10 + f"{title}" + "="*10 + "\nWhat would you like to know? (Type 'exit' to quit)")
                    
                    # ========== Chat with the assistant ==========
                    for _ in range(max_messages):  # Loop over messages
                        prompt = input("User:")
                        if prompt == "exit":
                            prompt = input("Getting tired of this pdf? How about a new one?\nEnter PDF path or type 'exit' to quit:")
                            break
                        messages = add_message(messages, prompt, "user")
                        response = get_response(messages)
                        messages = add_message(messages, response, "assistant")
                        print("Assistant:", response)
                except Exception as e:
                    print(f"Failed to read PDF: {e}")
            else:
                print("Invalid PDF path. Please provide a valid PDF file path.")
                continue

if __name__ == "__main__":
    chat()

